# 变量和基本类型

## 算术类型转换的几种情况

|           源类型           |  转换类型  |                 转换结果                 |
| :------------------------: | :--------: | :--------------------------------------: |
|         非布尔类型         |  布尔类型  |  初始值为0-->false，初始值不为0-->true   |
|          布尔类型          | 非布尔类型 |     初始值false-->0，初始值true-->1      |
|            浮点            |    整型    |          仅保留浮点数中整数部分          |
|            整型            |   浮点型   |              小数部分记为0               |
| 无符号类型取值范围之外的值 | 无符号类型 | 初始值对无符号类型数值总是取模之后的余数 |
| 有符号类型取值范围之外的值 | 有符号类型 |                  未定义                  |

> 当一个表达式中既含有有符号类型又含有无符号类型，有符号类型取值为负时，会将其自动的转换为无符号类型再进行计算

## 初始化与赋值的区别

初始化的含义是创建变量时赋予其一个初始值；

赋值的含义是将对象的当前值擦除，以一个新值来代替 

## 列表初始化

使用花括号来初始化变量，例如：

```c++
int tmp = {0};
int tmp{0};
```

列表初始化作用于内置类型的变量时有一个重要的特点：

如果使用列表初始化且初始值存在丢失信息的风险，则编译器将报错（或只是警告？），例如：

```c++
long double pi = 3.1415926;
int a{pi}, b = {pi};	// 编译器将会报错
int c(pi), d = pi;		// 不会报错，但是会丢失部分值
```

## 默认初始化

定义变量时如果没有指定初值，则变量被默认初始化。此时变量的值为默认值。

默认值由变量类型决定，同时与定义变量的位置也有关系：

* 对内置类型，定义于任何函数体外的变量被初始化为0；在函数体内部的变量将不会被初始化，此时变量的值是未定义的。
* 对于类类型，由各自的类决定其初始化对象的方式。

## 引用

引用即别名，通过将声明符写成 `&d` 的形式来定义引用类型，其中 `d` 是声明的变量名。

大部分引用的类型都要和与之绑定的对象严格匹配，例如：

```c++
doublt pi = 3.14;
int &ref = pi;	// 错误，引用类型必须是int型的对象
```

同时引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起，例如：

```c++
int &ref = 10;	//错误，10是字面值，不是对象
```

一旦定义了引用就无法令其再绑定到其他的对象；

## 复合类型之指向指针的引用

```c++
int i = 42;
int *p;
int *&r = p;
r = &i;
*r = 0;
```

要理解 `r` 的类型，最简单的方法是从右向左阅读 `r` 的定义：

首先是引用，引用的是一个指针，指针的类型是 `int`

## 引用类型与其引用对象类型一致的例外情况

初始化常量引用时允许使用任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可

```c++
int i = 10;
const int &ref = i;		// 允许const int&绑定到一个普通int对象

double pi = 3.14;
const int &ref2 = pi;	// ref2绑定了一个临时量对象
/*
 * 实际转换过程
 * const int tmp = pi;
 * const int &ref2 = tmp;
 * 如果ref2不是常量，那么就允许对ref2进行赋值，对一个临时量赋值是一个未定义的行为
 */
```

## 指向常量的指针和指针常量

指向常量的指针指的是不能通过该指针改变所指对象的值：

```c++
const double pi = 3.14;
double *ptr = &pi;			// 错误，ptr是个普通指针
const double *ptr2 = &pi；	// ptr2是一个指针double常量的指针
*ptr2 = 1；	// 错误，不能通过ptr2改变所指对象的值
```

常量指针指的是指针本身的值不会改变而非指针所指对象的值

```c++
double pi = 3.14;
double *const ptr = &pi;
*ptr = 2.0;		// 可以通过常量指针改变所指对象的值
double e = 2.718;
ptr = &e;		// 错误，不能改变ptr本身的值
```

## 顶层const和底层const

顶层表示指针本身是个常量

底层表示指针所指向的对象是一个常量

```c++
int i = 0;
const int *p = &i;	// 底层const
int *const p2 = &i;	// 顶层const
```

在执行对象的拷贝操作时，顶层 `const` 不受影响，但是底层 `const` 必须是对等的，或者说两个对象的数据类型必须能过转换。非常量可以转换成常量，反之不行

## constexpr 和常量表达式

常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式；

将变量声明为 `constexpr` 类型可以由编译器来验证变量的值是否是一个常量表达式；

用 `constexpr` 声明的变量一定是一个常量，且必须用常量表达式初始化；

一个 `constexpr` 指针的初始值必须是 `nullptr` 或者0，或者是存储与某个固定地址中的对象；

在`constexpr` 声明中如果定义了一个指针， `constexpr` 仅对指针有效，与指针所指向的对象无关；

```c++
const int *p = nullptr;		// 指向整型常量的指针
constexpr int *q = nullptr;	// 常量指针
```

## 类型别名

### `typedef`

```c++
typedef double wages;
```

### `using`

```c++
using SI = sales_item;
```

### 指针与类型别名

```c++
typedef char *pstring;
const pstring cstr = 0;	// 常量指针
```

`const` 是对给定类型的修饰，`pstring` 实际上是指向char的指针，`const pstring` 就是指向 `char` 的常量指针

```c++
const char *cstr = 0;	// 把类型别名替换成它原来的样子来理解是错误的；
```

> 符号&和* 只从属于某个声明符，而非基本数据类型的一部分

## auto

`auto` 定义的变量必须有初始值；

`auto` 一般会忽略顶层 `const` ，需要明确指出

```c++
const auto f = 0;
```

使用 `auto` 在一条语句中声明多个变量时，变量的初始基本类型必须一致：

```c++
auto i = 0, j = 1;
auto p = 1, q = 2.2;	// 错误
```

## decltype

`decltype` 选择并返回操作数的数据类型

```c++
decltype(f()) sum = x;	// sum的类型与f()的返回类型一致
```

如果 `decltype` 使用的表达式是一个变量，则返回该变量的类型，否者返回表达式结果对应的类型，如果表达式的内容是解引用，则得到的是引用类型：

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;	// x const int;
decltype(cj) y = x; // y const int&

int i = 42, *p = &i, &r = i;
decltyoe(r + 0) b;	// b int
decltype(*p) c; 	// 错误，c int& 需要初始化
```

`decltype` 的结果与表达式形式密切相关；

如果 `decltype` 的变量加上了一对括号，`decltype` 会把它当初表达式，`decltype((variable))` 的结果永远是引用，不加括号则得到的结果就是该变量的类型；

```c++
int i = 0;
decltype(i) e;	// i int
decltype((i)) f;// f int& 需要初始化
```

