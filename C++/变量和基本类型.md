# 变量和基本类型

## 算术类型转换

|           源类型           |  转换类型  |                 转换结果                 |
| :------------------------: | :--------: | :--------------------------------------: |
|         非布尔类型         |  布尔类型  |  初始值为0-->false，初始值不为0-->true   |
|          布尔类型          | 非布尔类型 |    初始值false-->0，初始值true-->true    |
|           浮点数           |    整型    |          仅保留浮点数中整数部分          |
|            整型            |   浮点型   |              小数部分记为0               |
| 无符号类型取值范围之外的值 | 无符号类型 | 初始值对无符号类型数值总是取模之后的余数 |
| 有符号类型取值范围之外的值 | 有符号类型 |                  未定义                  |

> 当一个表达式中既含有有符号类型又含有无符号类型，有符号类型取值为负时，会将其自动的转换为无符号类型再进行计算

## 变量

### 初始化与赋值

初始化的含义是创建变量时赋予其一个初始值，赋值的含义是将对象的当前值擦除，以一个新值来代替

### 嵌套的作用域

内层作用域中可以重新定义外层作用域 已有的名字

## 引用

大部分引用的类型都要和与之绑定的对象严格匹配，同时引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起，一旦定义了引用就无法令其再绑定到其他的对象

### 指向指针的引用

```c++
int i = 42;
int *p;
int *&r = p;
r = &i;
*r = 0;
```

要理解 `r` 的类型，最简单的方法是从右向左阅读 `r` 的定义；

首先是引用，引用的是一个指针，指针的类型是 `int`

##  `const` 限定符

### 引用类型与其引用对象类型一致的例外情况

* 初始化常量引用时允许使用任意表达式作为初始值，只要该表达式的结果能过转换成引用的类型即可

  ```c++
  doublt dval = 3.14;
  const int &ri = dval;
  int &rj = dval;	// 错误
  
  实际情况
  const int tmp = dval;
  const int &ri = tmp;
  ```

  > ri 绑定了一个临时量；如果 ri 不是常量，就允许通过 ri 赋值，此时对一个临时量进行赋值时未定义的

### 顶层 `const` 和底层 `const`

顶层表示指针本身是个常量

底层表示指针所指向的对象是一个常量

```c++
int i = 0;
const int *p = &i;	// 底层const
int *const p2 = &i;	// 顶层const
```

在执行对象的拷贝操作时，顶层 `const` 不受影响，但是底层 `const` 必须是对等的，或者说两个对象的数据类型必须能过转换。非常量可以转换成常量，反之不行

## `constexpr` 和常量表达式

常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式；

将变量声明为 `constexpr` 类型可以由编译器来验证变量的值是否是一个常量表达式；

用 `constexpr` 声明的变量一定是一个常量，且必须用常量表达式初始化；

一个 `constexpr` 指针的初始值必须是 `nullptr` 或者0，或者是存储与某个固定地址中的对象；

`constexpr` 仅对指针有效，与指针所指向的对象无关；

```c++
const int *p = nullptr;		// 指向整型常量的指针
constexpr int *q = nullptr;	// 常量指针
```

## 类型别名

### `typedef`

```c++
typedef double wages;
```

### `using`

```c++
using SI = sales_item;
```

### 指针与类型别名

```c++
typedef char *pstring;
const pstring cstr = 0;	// 常量指针
```

`const` 是对给定类型的修饰，`pstring` 实际上是指向char的指针，`const pstring` 就是指向 `char` 的常量指针

```c++
const char *cstr = 0;	// 把类型别名替换成它原来的样子来理解是错误的；
```

> 符号&和* 只从属于某个声明符，而非基本数据类型的一部分

### `auto`

`auto` 定义的变量必须有初始值；

`auto` 一般会忽略顶层 `const` ，需要明确指出

```c++
const auto f = 0;
```

### `decltype`

`decltype` 选择并返回操作数的数据类型

```c++
decltype(f()) sum = x;	// sum的类型与f()的返回类型一致
```

如果 `decltype` 使用的表达式是一个变量，则返回该变量的类型，否者返回表达式结果对应的类型

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;	// x const int;
decltype(cj) y = x; // y const int&

int i = 42, *p = &i, &r = i;
decltyoe(r + 0) b;	// b int
decltype(*p) c; 	// 错误，c int& 需要初始化
```

`decltype` 的结果与表达式形式密切相关；

如果 `decltype` 的变量加上了一对括号，`decltype` 会把它当初表达式，`decltype((variable))` 的结果永远是引用，不加括号则得到的结果就是该变量的类型；

```c++
int i = 0;
decltype(i) e;	// i int
decltype((i)) f;// f int&
```

