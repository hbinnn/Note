# 显示转换

一个命名的强制类型转换具有如下形式

```
cast-name<type>(expression);
```

其中， *type* 是转换的目标类型而 *expression* 是要转换的值；如果 *type* 是引用类型，则结果是左值；

*cast-name* 是 *static_cast* 、 *dynamic_cast* 、 *const_cast* 、 *reinterpret_cast* 中的一种；

## static_cast 

任何具有明确定义的类型转换，只要不包含底层 *const* ，都可以使用 *static_cast* ；

用于基本数据类型之间的转换，如 *int* 转换成 *char* ；

用于类层次结构中基类和派生类之间指针或引用的转换；进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）是不安全的；

## const_cast

*const_cast*  只能改变运算对象的底层 *const*

```
const char *pc;
char *p = const_cast<char *>(pc);	// 正确，但是通过p写值是未定义的行为
```

如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为；然而如果对象是一个常量，再使用 *const_cast*   执行写操作就会产生未定义的后果；

```
int arr[4] = {1, 2, 3, 4};
const int *p = arr;
int *p2 = const_cast<int *>(p);
p2[0] = 2;		// arr: 2, 2, 3, 4

const int m = 10;
int &n = const_cast<int &>(m);
n = 20;			// 未定义行为
```

## reinterpret_cast 

*reinterpret_cast* 将一个类型的指针转换为另一个类型的指针，这种转换不用改变指针变量值数据存放格式(不改变指针变量值)，只需在编译时重新解释指针的类型就可以做到；

不建议使用！

## dynamic_cast*

*dynamic_cast*  主要用来在继承体系中的安全向下转型。它能安全地将指向基类的指针转型为指向派生类的指针或引用，并获知转型动作成功是否。如果转型失败会返回 *null*（转型对象为指针时）或抛出异常（转型对象为引用时）。下行转换时要求基类是多态的（基类中包含至少一个虚函数）。 向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。

*dynamic_cast*  会动用运行时信息来进行类型安全检查，因此 *dynamic_cast*  存在一定的效率损失。

*dynamic_cast*  不能用于内置的基本数据类型的强制转换

```
class A {
public:
    virtual void funA() { }
};

class B : public A {
public:
    void funB() { }
};

 A *a = new A;
 A *a1;
 a1 = dynamic_cast<B *>(a);		// a1为null，转换失败，a1指向的实际类型与转换后的类型不同
 
 A *a = new B;
 A *a1;
 a1 = dynamic_cast<B *>(a);		// 转换成功
 
```

