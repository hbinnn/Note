# 动态内存与智能指针

## 智能指针的类型

`shared_ptr` 允许多个指针指向同一个对象；

`unique_ptr` 独占所指向的对象；

`weak_ptr` 是一种弱引用，指向 `shared_ptr` 所管理的对象；

## *shared_ptr* 类

最安全的分配和使用动态内存的方法是调用 `make_shared` 的标准库函数；此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 `shared_ptr` ， `make_shared` 用其参数来构造给定类型的对象；

当进行拷贝或赋值操作时，每个 `shared_ptr` 都会记录有多少个其他的 `shared_ptr` 指向相同的对象；可以认为每个 `shared_ptr` 都有一个关联的引用计数，无论何时拷贝一个 `shared_ptr` ，计数器都会递增；当给 `shared_ptr` 赋予一个新值或是 `shared_ptr` 被销毁时，计数器就会递减；将一个 `shared_ptr` 赋予另一个 `shared_ptr` 会递增赋值符右侧的引用计数，而递减左侧的引用计数；

当指向一个对象的最后一个 `shared_ptr` 被销毁时， `shared_ptr` 类会自动销毁此对象；

## *new* 与 *delete* 

动态分配的对象是默认初始化的；

```
int *p = new int;		// *p的值未定义
```

如果提供了一个括号包围的初始化器，就可以使用 *auto* 从此初始化器来推断要分配对象的类型；

```
auto p = new auto(obj);		// p指向一个与obj相同类型的对象，该对象使用obj进行初始化
auto p2 = new auto{a, b, c}; // 错误，括号中只能由单个初始化器
```

在内存耗尽的情况下， *new* 返回一个空指针，并且抛出一个类型为 *bad_alloc* 的异常，可以通过改变 *new* 的方式来阻止抛出异常，这种形式称为定位 *new* ；

```
int *p = new (nothrow) int;	
```

对于 *new* 分配的内存，在使用完毕后必须使用 *delete* 表达式将其归还给系统；

```
delete p;
```

传递给 *delete* 的指针必须是指向动态分配的内存，或者是一个空指针；释放一块非 *new* 分配的内存或者多次释放用一个指针，其行为是未定义的；

## *shared_ptr* 和 *new* 结合使用

可以使用 *new* 返回的指针来初始化智能指针

```
shared_ptr<int> p(new int(42));
shared_ptr<int> p2 = new int(42);	// 错误
```

接受指针参数的智能指针构造函数是 *explicit* 的，必须使用直接初始化的形式来初始化一个智能指针；同样，一个返回 *shared_ptr* 的函数不能在其返回语句中隐式转换一个普通指针；

```
shared_ptr<int> func() {
	return new int(42);	//错误
}

shared_ptr<int> func() {
	return shared_ptr<int>(new int(42));	//正确
}
```

不要使用 *get* 函数来初始化一个智能指针或为智能指针赋值，*get* 函数返回一个内置指针，指向智能指针指向的对象，适用于向不能使用智能指针的代码传递一个内置指针；使用 *get* 返回的指针的代码不能 *delete* 此指针

```
shared_ptr<int> p(new int(42));
int *q = p.get();	// 正确，但不能使用 delete
{
	shared_ptr(int)(q);	// 两个独立的shared_ptr指向同一对象
}	// q离开作用域被销毁，指向的内存被释放
int foo = *p;	// 未定义，p指向的内存已被释放
```

可以使用 *reset* 来讲一个新的指针赋予一个 *shared_ptr* ，*reset* 会更新引用计数

```
p.reset(new int(42));
```

## 智能指针和异常

对于使用智能指针管理的内存，即使程序块异常结束，智能指针类也能确保在内存不再需要时将其释放

```
void func()
{
	shared_ptr<int> p(new int(42));
	// 发生异常切未被捕获
}	// 函数结束时shared_ptr自动释放
```

对于直接管理的内存，如果在 *delete* 之前发生异常，则内存不会自动释放

```
void func()
{
	int *p = new int(42);
	// 发生异常切未被捕获
	delete p;	//如在new和delete之间发生异常，且未被捕获，则内存无法释放
}
```

默认情况下，当一个 `shared_ptr` 被销毁时，默认的对它管理的指针进行 *delete* 操作；

当我们创建一个 `shared_ptr` 时，可以传递（可选的）一个指向删除器函数的参数来代替 *delete* 操作；

```
void end(connect *p) { disconnect(*p); }

connection c = connect(&d);
shared_ptr<connection> p(&c, end);
```

当 *p* 被销毁时，不会调用 *delete* 而是调用 *end* ；

## *unique_ptr* 

与 `shared_ptr` 不同，某个时刻只能有一个 `unique_ptr` 指向一个给定对象，当 `unique_ptr` 被销毁时他所指向的对象也被销毁；

`unique_ptr` 不支持普通的拷贝或赋值操作，但是可以通过调用 *release* 或 *reset* 将指针所有权从一个`unique_ptr` 转移给另一个`unique_ptr` 

```
unique_ptr<int> p(new int(42));
unique_ptr<int> p2(p);	//错误，不支持拷贝
unique_ptr<int> p3;
p3 = p;	//错误，不支持赋值

unique_ptr<int> p2(p.release()); 	//p置为空
unique_ptr<int> p3(new int(52));
p2.reset(p3.release())	//p2原来指向的内存被释放
```

release 返回 `unique_ptr` 当前保存的指针并将其置位空

reset接受一个可选的指针参数，令 `unique_ptr` 重新指向给定的指针；如果`unique_ptr` 不为空，则它原来指向的对象被释放；

不能拷贝`unique_ptr` 有一个例外：可以拷贝或复制一个将要被销毁的`unique_ptr` ；

```
unique_ptr<int> func()
{
	return unique_ptr<int>(new int(42));
}
```

同样我们可以重载一个`unique_ptr` 默认的删除器

```
unique_ptr<objT, delT> p(new objT, fun);
```

```
void end(connect *p) { disconnect(*p); }

connection c = connect(&d);
unique_ptr<connection, decltype(end)*> p(&c, end);
```

## 动态数组

使用 *new* 分配一个数组对象，要在类型名之后跟一对方括号，分配一个空数组是合法的

```
int *p = new int[];
```

释放数组需要在指针前面加上一个空方括号对

```
delete [] p;
```

## 智能指针和动态数组

`unique_ptr` 可以直接管理动态数组，但`shared_ptr` 必须提供自己定义的删除器才能管理动态数组

```
unique_ptr<int[]> p(new int[10]);
p.release();	// 自动使用delete[]销毁

shared_ptr<int[]> p2(new int[10], []( int *p) { delete [] p; })	//必须提供一个删除器
p2.reset();
```

对于`unique_ptr` 管理的动态数组，可以使用下标运算符来访问数组中的元素，但是`shared_ptr` 则不能直接这么使用

```
for (size_t i = 0; i != 10; ++i) {
	p[i] = i;
}

for (size_t i = 0; i != 10; ++i) {
	*(p2.get() + i) = i;
}
```

## *allocator* 类

当分配一大块内存时，我们通常计划在这块内存上按需构造对象，将内存分配与构造对象分离开；而 *new* 操作在分配空间的同时构造了对象，但这些对象不一定全部都会被使用，另外对于没有默认构造函数的类就不能使用动态分配数组了；

*allocator* 类提供了将内存分配和对象构造分开的方式，它分配的内存是原始的、未构造的；

```
allocator<string> alloc;	//可以分配string的allocator对象
auto const p = alloc.allocate(n);	//分配n个未初始化的string， p指向最后构造的元素之后的位置
```

可以使用 *construct* 函数对分配的内存进行构造

```
auto q = p;
alloc.construct(q++);	//*q为空string
alloc.construct(q++, 10, 'c'); 
alloc.construct(q++, "hi");
```

释放内存可以通过调用 *deallocate* 函数

```
alloc.deallocate(p, n);
```

传递给*deallocate* 的指针不能位空，必须指向由 *allocate* 分配的内存，且 *deallocate* 大小参数必须与调用 *allocate* 分配时的大小参数相同；

## 相关的成员函数

![image-20210323234814142](C:\Users\huangshibin\Desktop\Note\C++\动态内存与智能指针.assets\image-20210323234814142.png)

![image-20210323234844653](C:\Users\huangshibin\Desktop\Note\C++\动态内存与智能指针.assets\image-20210323234844653.png)

![image-20210323234853045](C:\Users\huangshibin\Desktop\Note\C++\动态内存与智能指针.assets\image-20210323234853045.png)

![image-20210323234908753](C:\Users\huangshibin\Desktop\Note\C++\动态内存与智能指针.assets\image-20210323234908753.png)

![image-20210323234928682](C:\Users\huangshibin\Desktop\Note\C++\动态内存与智能指针.assets\image-20210323234928682.png)

![image-20210323234941029](C:\Users\huangshibin\Desktop\Note\C++\动态内存与智能指针.assets\image-20210323234941029.png)

![image-20210323234949341](C:\Users\huangshibin\Desktop\Note\C++\动态内存与智能指针.assets\image-20210323234949341.png)

