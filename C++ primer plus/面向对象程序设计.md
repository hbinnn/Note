# 面向对象程序设计

## 继承

通过**继承**联系在一起的类构成一种层次关系；

在层次关系的根部有一个**基类**，其他类直接或间接的从基类继承而来，称为**派生类**；

基类定义所有类共同拥有的成员，派生类定义各自特有的成员；

派生类必须通过使用**类派生列表**明确的指出它是从哪些基类继承而来；

## 动态绑定

当使用基类的引用或指针调用一个虚函数时将发生动态绑定，此时运行函数的版本由实参决定；

根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行派生类的版本；

## 成员函数与继承

对于某些函数，基类希望派生类各自定义适合自身的版本，此时基类就将这些函数声明为**虚函数**，派生类可以根据各自的需要对这些虚函数进行声明重新定义；

关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义；

如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数；

## 访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权利访问从基类继承而来的成员；

派生类可以访问公有成员和受保护的成员，不能访问私有成员；

protected：对类的用户来说是不可访问的，对派生类的成员和友元来说是可访问的；派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于基类对象中的受保护成员没有任何访问特权；

## 友元继承关系

不能继承友元关系，每个类负责控制各自成员的访问权限；

## 派生类对象

一个派生类对象包含多个组成部分：派生类自己定义的成员子对象、与该派生类继承的基类对应的子对象；

## 类型转换与继承

### 派生类向基类的类型转换

派生类中含有其基类对应的组成部分，所以可以把一个派生类对象当成一个基类对象来用，也可以将一个基类的指针或引用绑定到一个派生类对象的基类部分上；

### 静态类型与动态类型

静态类型时变量声明时的类型或表达式生成的类型；

动态类型是变量或表达式表示的内存中的对象的类型；

动态类型直到运行时才可知；

### 不存在从基类向派生类的隐式类型转换

即使将一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类向派生类的转换；

### 对象之间不存在类型转换

类型转换只针对指针或引用类型有效；

## 派生类构造函数

每个类控制自身的成员初始化过程，派生类也必须使用基类的构造函数来初始化他的基类部分；

## 继承与静态成员

如果基类中定义了一个静态成员，无论派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例；

静态成员遵循通用的访问控制规则；

## 防止继承的发生

在类名后跟一个关键字final；

同样也可以将某个函数指定为final，后续任何尝试覆盖该函数的操作都将引发错误；

## 派生类中的虚函数

派生类中的函数入股覆盖了某个继承而来的虚函数，则他的形参类型和返回类型必须与基类函数完全一致；

有一个例外情况：当虚函数返回类型是类本身的指针或引用时，上诉规则无效；

可以使用override关键字来说明派生类中的虚函数；

## 虚函数与默认实参

如果虚函数使用了默认实参，则该实参值由本次调用的静态类型决定；

## 回避虚函数的机制

如果不希望对虚函数的调用执行动态绑定而是强迫其执行某个特定版本的虚函数，可以使用作用域运算符来实现；

## 纯虚函数

在函数体的声明语句的分号前书写=0就可以将一个虚函数说明为纯虚函数，=0只能出现在类内部；

纯虚函数也可以提供定义，不过函数体必须定义在类的外部；

## 抽象基类

含有纯虚函数的类时抽象基类，抽象基类负责定义接口，后续的其他类可以覆盖该接口；

不能直接创建一个抽象基类的对象；

## 继承中的类作用域

派生类的作用域嵌套在其基类的作用域之内，如果一个名字在派生类的作用域内无法解析，则编译器将继续在外层的基类作用域中寻找该名字的定义；

派生类的成员将隐藏同名的基类成员，可以通过作用域运算符来使用一个被隐藏的基类成员；

## 函数调用的解析过程

假定调用p->mem()

- 首先确定p的静态类型
- 在p的静态类型中寻找mem，如果找不到，在其直接基类中依次查找直到到达继承链的顶端，如果仍找不到则报错
- 一旦找到，进行常规的类型检查
- 假设调用合法，将根据调用的是否是虚函数而产生不同的代码
- 如果是虚函数且通过指针或引用进行的调用，则依据对象的动态类型确定虚函数的版本
- 如果不是，则产生一个常规调用

## 虚析构函数

delete一个动态分配的对象的指针时将执行析构函数，如果该指针指向继承体系中的某个类型，则 有可能出现指针的静态类型与被删除对象的动态类型不符的情况；

可以通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本；

## 派生类的拷贝控制成员

派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员；

## 派生类析构函数

派生类析构函数只负责销毁由派生类自己分配的资源

对象销毁的顺序与其创建顺序正好相反：派生类析构函数首先执行，然后是基类析构函数，以此类推

## 构造函数和析构函数中调用虚函数

应该执行与构造函数或析构函数所属类型相对于的虚函数版本