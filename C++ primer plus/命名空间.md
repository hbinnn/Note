# 命名空间

## 命名空间定义

一个命名空间的定义包含两部分：关键字  `namespace` 、命名空间的名字

```c++
namespace A {
    ...
}
```

命名空间的名字也必须在定义它的作用域内保持唯一；

每个命名空间都是一个作用域，不同命名空间的作用域不同，因此在不同的命名空间中可以出现相同名字的成员；

```c++
namespace A {
    void Fun();
}
namespace B {
    void Fun();
}
```

命名空间可以是不连续的，例如

```c++
namespace A {
    ...
}
```

可能是定义了一个名为A的命名空间，也可能是在已有的A的命名空间基础上添加一些新的成员；

## 内联命名空间

内联命名空间中的名字可以直接被外层命名空间使用；

定义内联命名空间的方式是在关键字 `namespace` 前加关键字 `inline` ：

```c++
inline namespace A {
	...
}
```

`inline` 必须写在命名空间第一次定义的地方，后续再打开命名空间的时候可写可不写；

## 全局命名空间

全局作用域中定义的名字（在所有类、函数以及命名空间之外定义的名字）也就是定义在全局命名空间中；

全局命名空间以隐式的方式声明，并且在所有程序中都存在；

作用域运算符同样可以作用域全局作用域的成员，并且全局作用域没有名字

```c++
::member_name
```

## 未命名的命名空间

未命名的命名空间是指关键字 `namespace` 后紧跟着花括号括起来的一系列声明语句：

```c++
namespace {
    ...
}
```

未命名的命名空间中定义的变量拥有静态生命周期；

未命名的命名空间可以在给定的文件内不连续，但是不能够跨越多个文件；

定义在未命名的命名空间内的名字可以直接使用；

如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字要与全局作用域中的民资有所区别：

```c++
int i;
namespace {
    int i;
}
i = 10;		// 二义性
```

# 使用命名空间成员

## 别名

```c++
namespace s = std;
```

不能在命名空间还没有定义前就声明别名；

## using声明

```c++
using std::cout;
```

## using指示

```c++
using namespace std;
```

`using` 指示具有将命名空间成员提升到包含命名空间本身和 `using` 指示的最近作用域的能力

```c++
namespace blip {
    int i = 1;
    int j = 2;
    int k = 3;
}
int j = 0;
void fun() {
    using namespace blip;	// blip的成员被添加到全局作用域中
    ++j;	// 二义性错误，是::j 还是 blip::j
    ++::j;	// 正确
    ++blip::j;	// 正确
}
```

