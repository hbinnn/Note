# 模板与泛型编程

## 函数模板

```c++
template <typename T>
int fun(const T& arg)
{
    ...
    return 0;
}
```

模板定义以 *template* 开始，后面跟一个模板参数列表，在模板定义中，该列表不能为空；

模板类型参数前必须使用 *typename* 或 *class*

## 模板编译

当编译器遇到一个模板定义时并不会生产代码，只有当我们实例化出模板的一个特点版本时，编译器才会生产代码；

为了生产一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义；因此模板的头文件通常即包含声明也包含定义。

## 模板编译错误

编译器通常会在三个阶段报告错误：

1、编译模板本身，可以检查一些语法错误；

2、模板使用，对于函数模板调用，编译器通常会检查实参数目是否正确，参数类型是否匹配；对于类模板，编译器会检查用户是否提供了正确数目的模板实参；

3、模板实例化

## 类模板

编译器无法为类模板推断模板参数类型，因此在使用类模板时必须在模板名后的尖括号中提供额外信息，用来替代模板参数的模板实参列表：

```c++
template <typename key_t, typename value_t>
class LRU {
public:
	void Put(const key_t& key, const value_t& value);    
};

template <typename key_t, typename value_t>
LRU<key_t, value_t>::Put(const key_t& key, const value_t& value) {
    ...
}

LRU<int, int> cache;
```

## 类模板和友元

如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例；如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

### 一对一友好关系

```c++
template <typename> class BlobPtr;

template <typename T>
class Blob {
    friend class BlobPtr<T>;	// 每个Blob实例将访问权限授予用相同类型实例化的BlobPtr；
};
```

### 通用和特定的模板友好关系

```c++
template <typename T> class Pal;

class C {
	friend class Pal<C>;	// 用类C实例化的Pal是C的友元；
    template <typename T> friend class Pal2;	// Pal2的所有实例都是C的友元；
};

template <typename T>
class C2 {
    friend class Pal<T>;	// 用相同类型实例化的Pal是C2的每个实例的友元；
    template <typename X> friend class Pal2;	// Pal2的所有实例都是C2的每个实例的友元
	friend class Pal3;	// Pal3是C2所有实例的友元
};
```

为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。

## 模板类型别名

```c++
typedef Blob<string> strBlob;
typedef Blob<typename T> TBlob;	// 错误；

template <typename T> using twin = pair<T, T>;	// 正确
twin<string> authors;	// pair<string, string> authors;

template <typename T> using partNo = pair<T, unsigned>;	// 正确，定义别名时可以固定一个或多个模板参数；
```

## 默认模板实参

```c++
template <typename T, typename F = less<T>>
int compare(const T& v1, const T& v2, F f = F()) {
    ...
}
```

## 模板默认实参

```c++
template <typename T = int>
class Numbers {
    ...
};

Numbers<double> num1;
Numbers<> num2;	// 空<>表示希望使用默认类型
```

## 成员模板

### 普通类的成员模板

```c++
class C {
public:
    template <typename T> void fun() {
        ...
    }
};
```

### 类模板的成员函数

类和成员各自有自己的、独立的模板参数；

在类外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表，类模板的参数列表在前，后跟成员函数自己的模板参数列表：

```c++
template <typename T>
class C {
public:
    template <typename U> void fun() {
        ...
    }
}

template <typename T>
template <typename U>
C<T>::fun() {
    ...
}
```

## 控制实例化

当多个独立编译的源文件使用了相同的模板并提供相同的模板参数时，每个文件中就会有一个该模板的实例；

可以通过显示实例化的方式来避免这种实例化相同模板的开销：

```c++
extern template class Blob<string>;	// 实例化声明
template int compare(const int&, const int&);	// 实例化定义
```

## 模板类型参数转换

能够应用于函数模板的类型转换有两项：

1、*const* 转换：非 *const* -> *const*

2、数组或函数指针的转换：如果函数形参不是引用类型，数组实参可以转换为一个指向其首元素的指针，函数实参可以转换为一个该函数类型的指针

不能应用于函数模板的转换：算术转换、派生类向基类的转换、用户定义的转换

```c++
template <typename T> T fun1(T, T);
template <typename T> T fun2(const T&, const T&);

string s1("hello");
const string s2("world");
fun1(s1, s2);	// 调用fun1(string, string);
fun2(s1, s2);	// 调用fun2(const string&, const string&);

int a[10], b[42];
fun1(a, b);	// 调用fun1(int *, int*);
fun2(a, b);	// 错误，a的类型为(&a)[10], b的类型为(&b)[42];
```

## 函数模板显式实参

```c++
template <typename T1, typename T2, typename T3>
T1 sum(T2, T3);

auto val3 = sun<long long>(1, 1);	// long long sum(int, int);
```

显式模板实参按从左到右的顺序与对应的模板参数匹配，只有最右参数的显式模板实参才可以忽略，而且前提是他们可以从函数参数中推断出来。

## 尾置返回类型

当我们并不知道函数准确的返回类型时可以通过尾置返回类型来确定：

```c++
template <typename T>
auto &fun(T begin, T end) -> decltype(*begin)
{
    ...
    return *begin;
}
```

## 类型转换的标准库模板类

头文件 *type_traits*

| Mod<T>,Mod为         | T                           | Mod<T>::type      |
| -------------------- | --------------------------- | ----------------- |
| remove_reference     | X&或X&&<br />否则           | X<br />T          |
| add_const            | X&、const X或函数<br />否则 | T<br />const T    |
| add_lvalue_reference | X&<br />X&&<br />否则       | T<br />X&<br />T& |
| add_rvalue_reference | X&或X&&<br />否则           | T<br />T&&        |
| remove_pointer       | X*<br />否则                | X<br />T          |
| add_pointer          | X&或X&&<br />否则           | X*<br />T         |
| make_signed          | unsigned X<br />否则        | X<br />T          |
| make_unsigned        | 带符号类型<br />否则        | unsigned X<br />T |
| remove_extent        | X[n]<br />否则              | X<br />T          |
| remove_all_extents   | X[n1] [n2]...<br />否则     | X<br />T          |

```c++
template <typename T>
auto &fun(T begin, T end) -> typename remove_reference(decltype(*begin))::type
{
    ...
    return *begin;
}
```

## 函数指针与实参推断

当使用一个函数模板初始化一个函数指针时，编译器使用指针的类型来推断模板实参：

```c++
template <typename T> int compare(const T&, const T&);
int (*fun)(const int&, const int&) = compare;	// T为int类型

void (*fun)(const string&, const string&);
fun(compare);	// 编译错误，二义性，不知道使用那个fun

fun(compare<int>);	// 正确，使
```

## 模板实参推断与引用

### 从左值引用函数参数推断类型

```c++
template <typename T> void f1(T&);	// 实参必须是一个左值
int i;
const int ci;
f1(i);	// T int
f1(ci);	// T const int
f1(10);	// 错误，传递了一个右值

template <typename T> void f2(const T&);
f2(ci);	// T int
```

### 从右值引用函数参数推断类型

```c++
template <typename T> void f3(T&&);
f3(10);	// T int
```

### 引用折叠和右值引用参数

通常不能将一个右值引用绑定到一个左值上，但是有两个例外规则：

1、将一个左值传递给函数的右值引用参数，并且此右值引用参数指向模板类型参数（*T&&*）是，编译器推断模板类型参数为实参的左值引用类型

```c++
f3(i);	// T int&
```

通常不能直接定义一个引用的引用，但是可以通过类型别名或模板类型参数间接定义

2、如果间接创建一个引用的引用，则这些引用形成了折叠：

* *X& &*、*X& &&* 和 *X&& &* 都折叠成类型 *X&*
* 类型 *X&& &&* 折叠成 *X&&*

如果一个函数参数是一个指向模板类型参数的右值引用，则它可以被绑定到一个左值；如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个左值引用参数；

我们可以将任意类型的实参传递给 *T&&* 类型的函数参数

```c++
template <typename T> void f3(T&& val)
{
    T t = val;	// 拷贝还是引用？
    t = fcn(t);
    if (val == t) {
        ...
    }
}

f3(42);	// 对一个右值调用f3，T为int，此时t为拷贝初始化
f3(i);	// 将左值绑定到右值引用上，T为int&，此时t为引用
```

## std::move

*std::move* 的定义

```c++
template <typename T>
typename remove_reference<T>::type&& move(T&& t)	// T&&, 可以与任意类型的实参匹配
{
    return static_cast<remove_reference<T>::type&&>(t);	// 右值引用的特殊规则，允许static_cast显式的将一个左值转换为右值引用
}

string s1("hello"), s2;
s2 = std::move(string("world"));	// 从右值移动数据
s2 = std::move(s1);		// 赋值后s1的值是不确定的
```

## std::forward

*forward* 必须通过显式模板实参来调用，返回该显式实参类型的右值引用；

通过 *forward* 传递那些定义为模板类型参数的右值引用的函数参数，通过引用折叠，*forward* 可以保持给实参的左值/右值属性

```c++
template <typename T> fun(T&& arg)
{
    fun2(std::forward<T>(arg));
    ...
}
```

## 重载与模板

函数模板可以被另一个模板或者普通非模板函数重载；函数匹配规则：

1、对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例；

2、可行函数按类型转换来排序

3、如果恰好有多个函数提供同样好的匹配：

* 同样好的函数中只有一个函数是非模板函数，则选择此函数；
* 同样好的函数中没有非模板函数，且有多个模板函数，选择最特例化的函数模板
* 调用有歧义

## 可变参数模板

模板参数包：表示零个或多个模板参数；

函数参数包：表示零个或多个函数参数；

```c++
template <typename T, typename... Args>	// class...或teypename...指出接下来的参数表示零个或多个类型的列表
void fun(const T& t, const Args&... rest);	// 类型名后跟...表示零个或多个给定类型的非类型参数的列表

int i = 0;
double pi = 3.14;
string s = "hello";

fun(i, s, pi, 42);	// fun(const int&, const string&, const double&, const int&);
fun(i, s, pi);	// fun(const int&, const string&, const double&);
fun(i, s);	// fun(const int&, const string&);
```

可以使用 *sizeof...* 来获取参数包中有多少个参数

可变参数函数通常是递归调用的，需要定义一个非可变参数的同名函数

```c++
template <typename T>
ostream& print(ostream& os, const T& t)
{
    return os << t;
}

template <typename T, typename... Args>
ostream& print(ostream& os, const T& t, const Args... rest)
{
    os << t << endl;
    return print(os, rest...);	// rest中的第一个参数被绑定到t，剩下的参数变成了print调用的参数包
}
```

*rest...* 这种形式称为包扩展操作；扩展中的模式会独立的应用于包中的每个元素：

```c++
template <typename T, typename... Args>
ostream& print1(ostream& os, const T& t, const Args... rest)
{
    return print1(os, fun(rest)...);	// 对rest中的所有元素都调用fun()函数
}
```

利用右值引用参数、扩展包和转发实现 *emplace_back*

```c++
template <typename... Args>
void emplace_back(Args&&... rest)
{
    alloc();
    alloc.construct(first_free++, std::forward<Args>(rest)...);
}
```

## 模板特例化

特例化一个函数模板时，必须为原模版中的每个模板参数提供实参：

```c++
template <typename T, typename U>
int compare(const T&, const U&);

template <>
int compare(const char* const& p1, const char* const& p2);
```

特例化本质上是模板的一个实例，而非函数名的一个重载版本；

> 为了特例化一个模板，原模版的声明必须在作用域内；
>
> 在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域内；
>
> 如果丢失了一个特例化版本的声明，编译器通常可以根据原模版生产代码，很容易产生模板及其特例化版本声明顺序导致的错误；
>
> 通常模板及其特例化版本应该声明在同一个头文件中，所有同名模板的声明放在前面，然后是其特例化版本。

类模板特例化：

```c++
namespace std {	// 必须在原模板所在的命名空间中特例化
	template <>
    struct hash<data> {
        typedef size_t result_type;
        typedef data argument_type;
        size_t operator()(const data& d) const;
    }
    
    size_t hash<data>::operator()(const data& d) const {
        ...
    }
}
```

类模板偏特化：可以只指定一部分而非所有的模板参数，偏特化本身依旧还是一个模板；

>只能偏特化类模板，不能偏特化函数模板

```c++
template <typename T> struct  remove_reference {
    typedef T type;
}

template <typename T> struct remove_reference<T&> {
    typedef T type;
}

template <typename T> struct remove_reference<T&&> {
    typedef T type;
}
```

特例化成员而非类：

```c++
template <typename T>
class Foo {
    void Bar();
    ...
}

template <>
void Foo<int>::Bar()
{
    ...
}
```







